

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: exmg-sortable/exmg-sortable-base.js | Source: exmg-sortable/exmg-sortable-base.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 150px; height: 50px">
        
            <img src="https://www.exmachinagroup.com/images/svg/ExMachinaPrimary.svg" width="100%" height="100%">
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Source: exmg-sortable/exmg-sortable-base.js</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="Exmg.EditorElement.html">EditorElement</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Exmg.EditorElement_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Exmg.EditorElement.html#getToolbar">getToolbar</a></li><li><a href="Exmg.EditorElement.html#updateDocHistory">updateDocHistory</a></li></ul></div></li><li><a href="ExmgButton.html">ExmgButton</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgButton_sub"></div></li><li><a href="ExmgCollapsed.html">ExmgCollapsed</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgCollapsed_sub"></div></li><li><a href="ExmgCopyToClipboard.html">ExmgCopyToClipboard</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgCopyToClipboard_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExmgCopyToClipboard.html#copyToClipboard">copyToClipboard</a></li><li><a href="ExmgCopyToClipboard.html#handleCopyAction">handleCopyAction</a></li></ul></div></li><li><a href="ExmgDrawer.html">ExmgDrawer</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgDrawer_sub"></div></li><li><a href="ExmgForm.html">ExmgForm</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgForm_sub"></div></li><li><a href="ExmgFormDrawer.html">ExmgFormDrawer</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgFormDrawer_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExmgFormDrawer.html#error">error</a></li></ul></div></li><li><a href="ExmgGrid.html">ExmgGrid</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgGrid_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="ExmgGrid.html#disableRowClickSelection">disableRowClickSelection</a></li><li><a href="ExmgGrid.html#expandedRowIds">expandedRowIds</a></li><li><a href="ExmgGrid.html#hiddenColumnNames">hiddenColumnNames</a></li><li><a href="ExmgGrid.html#items">items</a></li><li><a href="ExmgGrid.html#rowsSelectable">rowsSelectable</a></li><li><a href="ExmgGrid.html#rowsSortable">rowsSortable</a></li><li><a href="ExmgGrid.html#selectedRowIds">selectedRowIds</a></li><li><a href="ExmgGrid.html#sortable">sortable</a></li><li><a href="ExmgGrid.html#tableLayout">tableLayout</a></li></ul></div></li><li><a href="ExmgGridBaseToolbar.html">ExmgGridBaseToolbar</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgGridBaseToolbar_sub"></div></li><li><a href="ExmgGridPagination.html">ExmgGridPagination</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgGridPagination_sub"></div></li><li><a href="ExmgSidemenu.html">ExmgSidemenu</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgSidemenu_sub"></div></li><li><a href="ExmgSidemenuHeader.html">ExmgSidemenuHeader</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgSidemenuHeader_sub"></div></li><li><a href="ExmgTooltip.html">ExmgTooltip</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="ExmgTooltip_sub"></div></li><li><a href="SortableElement.html">SortableElement</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="SortableElement_sub"></div></li></ul></div><div class="lnb-api hidden"><h3>Global</h3><ul><li><a href="global.html#orientationMap">orientationMap</a></li><li><a href="global.html#selectionController">selectionController</a></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { __decorate } from "tslib";
import { html } from 'lit';
import { ExmgElement } from '@exmg/exmg-base';
import { property } from 'lit/decorators.js';
import { addListener, removeListener } from '@exmg/exmg-base/utils/gestures.js';
/**
 * Orientation map to limit dragging to horizontal or vertical.
 */
const orientationMap = {
    horizontal: { x: 1, y: 0 },
    vertical: { x: 0, y: 1 },
};
export class SortableElementBase extends ExmgElement {
    constructor() {
        super();
        this.itemSelector = 'li';
        this.animationEnabled = false;
        this.clonedClass = 'cloned';
        this.draggedClass = 'dragged';
        this.animationTiming = { duration: 200, easing: 'ease-out' };
        this.dragRequestPending = false;
        this.sortableNodes = [];
        this.animatedElements = [];
        this.initialScrollTop = 0;
        /* Save function references */
        this.handleTrack = this.handleTrack.bind(this);
    }
    connectedCallback() {
        super.connectedCallback();
        addListener(this.getSortableHost(), 'track', this.handleTrack);
    }
    disconnectedCallback() {
        removeListener(this.getSortableHost(), 'track', this.handleTrack);
        super.disconnectedCallback();
    }
    updated(changedProperties) {
        if (changedProperties.has('sortableHostNode')) {
            // reset listeners when sortableHostNode changed
            removeListener(changedProperties.get('sortableHostNode') || this, 'track', this.handleTrack);
            addListener(this.getSortableHost(), 'track', this.handleTrack);
            if (this.sortableHostNode) {
                // sortable host must have position relative
                this.sortableHostNode.style.position = 'relative';
            }
        }
    }
    /**
     * Get instance of sortable host.
     * By default it is `exmg-sortable` which can be overridden by property `sortableHostNode`
     */
    getSortableHost() {
        if (this.sortableHostNode) {
            return this.sortableHostNode;
        }
        return this;
    }
    /**
     * Tracks a pointer from touchstart/mousedown to touchend/mouseup. Note that the start state is fired following
     * the first actual move event following a touchstart/mousedown.
     */
    handleTrack(e) {
        switch (e.detail.state) {
            case 'start':
                if (!this.dragRequestPending) {
                    this.trackStart(e);
                }
                break;
            case 'track':
                this.trackMove(e);
                break;
            case 'end':
                if (this.animationPromise) {
                    this.animationPromise.then(() => {
                        setTimeout(() => this.trackEnd());
                    });
                }
                else {
                    setTimeout(() => this.trackEnd());
                }
                break;
        }
    }
    /**
     * Initialized a drag and drop sequence if a child node was clicked that matches the itemSelector property. If a
     * handleSelector is defined, a node matching this selector must be clicked instead.
     */
    trackStart(e) {
        const handle = this.handleSelector;
        const eventPath = e.path ? e.path : e.composedPath();
        const targetElement = eventPath[0];
        /* Look for closest handle */
        if (handle &amp;&amp; !targetElement.closest(handle)) {
            return;
        }
        this.updateUserSelectStyle('none');
        this.dragRequestPending = true;
        const selector = this.itemSelector;
        const node = targetElement.closest(selector);
        if (node) {
            e.preventDefault();
            this.draggedElement = node;
            this.sortableNodes = Array.from(this.getSortableHost().querySelectorAll(selector)) || [];
            this.draggedElementClone = this.createClone(node);
            this.draggedElementOrigin = node.nextSibling;
            this.animatedElements = [];
            this.draggedElement.classList.add(this.draggedClass);
        }
    }
    /**
     * Ends the drag and drop sequence.
     */
    trackEnd() {
        if (!this.draggedElement) {
            return;
        }
        const updated = Array.from(this.getSortableHost().querySelectorAll(this.itemSelector));
        const sourceIndex = this.sortableNodes.indexOf(this.draggedElement);
        const targetIndex = updated.indexOf(this.draggedElement);
        if (sourceIndex !== targetIndex) {
            this.dispatchEvent(new CustomEvent('dom-order-change', {
                bubbles: true,
                composed: true,
                detail: {
                    sourceIndex,
                    targetIndex,
                },
            }));
        }
        this.reset();
        this.dragRequestPending = false;
        this.updateUserSelectStyle('text');
    }
    /**
     * Moves the active node's clone to follow the pointer. The node that the clone intersects with (via hitTest) is
     * the insert point for updated sorting.
     */
    trackMove(e) {
        e.preventDefault();
        if (!this.draggedElementClone) {
            return;
        }
        let { dx, dy } = e.detail;
        const scrollTop = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
        if (this.orientation) {
            dx = dx * orientationMap[this.orientation].x;
            dy = dy * orientationMap[this.orientation].y;
        }
        /* Work around for issue with first element being party offscreen when drag start */
        dy = dy - (this.initialScrollTop - scrollTop);
        Object.assign(this.draggedElementClone.style, {
            transform: `translate3d(${dx}px, ${dy}px, 0)`,
        });
        const target = this.hitTest(this.draggedElementClone, this.sortableNodes)[0];
        if (
        // if clone intersects with a valid target,
        target &amp;&amp;
            // other than its own origin,
            target !== this.draggedElement &amp;&amp;
            // and the target isn't currently animating, which causes false hit tests,
            !this.isAnimating(target)) {
            this.insertAtTarget(this.draggedElement, target);
        }
    }
    updateUserSelectStyle(userSelect) {
        /**
         * Firefox bug fix: when dragging elements in firefox, closest text also getting selected
         */
        this.style.userSelect = userSelect;
        this.style.MozUserSelect = userSelect;
        // @ts-ignore
        this.style.msUserSelect = userSelect;
        this.style.webkitUserSelect = userSelect;
    }
    /**
     * Fast and simple hit test to check whether the center of a node intersects with the rectangle of any of the
     * given targets. Returns an array of matches.
     *
     * @param {HTMLElement} node
     * @param {Array} targets
     * @return {Array&lt;HTMLElement>} matches
     */
    hitTest(node, targets) {
        const { left: l, top: t, width: w, height: h } = node.getBoundingClientRect();
        const x = l + w / 2;
        const y = t + h / 2;
        return targets.filter((item) => {
            const { left, right, top, bottom } = item.getBoundingClientRect();
            return !(x &lt; left || x > right || y &lt; top || y > bottom);
        });
    }
    /**
     * Returns a boolean indicating whether the node is currently in an animation.
     *
     * @param {HTMLElement} node
     * @returns {boolean} isAnimating
     */
    isAnimating(node) {
        return this.animatedElements.indexOf(node) !== -1;
    }
    reset() {
        if (this.draggedElementClone !== undefined &amp;&amp; this.draggedElementClone.parentNode !== null) {
            this.draggedElementClone.parentNode.removeChild(this.draggedElementClone);
        }
        if (this.draggedElement &amp;&amp; this.draggedElement.parentNode &amp;&amp; this.draggedElementOrigin) {
            this.draggedElement.classList.remove(this.draggedClass);
            this.draggedElement.parentNode.insertBefore(this.draggedElement, this.draggedElementOrigin);
        }
        delete this.draggedElementClone;
        delete this.draggedElement;
        this.sortableNodes = [];
        this.animatedElements = [];
        this.dragRequestPending = false;
        this.updateUserSelectStyle('text');
    }
    /**
     * Triggers a CSS animation on a node with the given dx and dy. Used following dom updates to make it appear as
     * if nodes animate from their old to their new position in the dom.
     *
     * @param {Node} node
     * @param {number} dx
     * @param {number} dy
     */
    animateNode(node, dx = 0, dy = 0) {
        if (!node.animate) {
            return;
        }
        // keep a stack of currently animating nodes to exclude as drag &amp; drop targets.
        this.animatedElements.push(node);
        Object.assign(node.style, {
            willChange: 'transform',
        });
        // animate from dx/dy (old node position) to none (new node position)
        this.animationPromise = new Promise((resolve) => {
            node
                .animate([{ transform: `translate3d(${dx}px, ${dy}px, 0)` }, { transform: 'none' }], this.animationTiming)
                .addEventListener('finish', () => {
                const index = this.animatedElements.indexOf(node);
                Object.assign(node.style, {
                    willChange: 'initial',
                });
                if (index !== -1) {
                    // splice out when done to unlock as a valid target
                    this.animatedElements.splice(index, 1);
                }
                resolve();
                delete this.animationPromise;
            });
        });
    }
    /**
     * Inserts node at target to update sibling sorting. If the node precedes the target, it is inserted after it;
     * If it follows the target, it is inserted before it. This ensures any node can be dragged from the very
     * beginning to the very end and vice versa. The animateNode function is called for all nodes that moved because
     * of this dom update.
     *
     * @param {Node} node
     * @param {Node} target
     */
    insertAtTarget(node, target) {
        let offsets = [];
        if (this.animationEnabled) {
            offsets = this.sortableNodes.map((item) => ({
                x: item.offsetLeft,
                y: item.offsetTop,
            }));
        }
        if (node &amp;&amp; node.parentNode) {
            const insert = node.compareDocumentPosition(target) &amp; this.DOCUMENT_POSITION_FOLLOWING ? target.nextSibling : target;
            node.parentNode.insertBefore(node, insert);
        }
        if (this.animationEnabled) {
            this.sortableNodes.forEach((sortableNode, i) => {
                const { x, y } = offsets[i];
                const dx = x - sortableNode.offsetLeft;
                const dy = y - sortableNode.offsetTop;
                if (dx !== 0 || dy !== 0) {
                    this.animateNode(sortableNode, dx, dy);
                }
            });
        }
    }
    /**
     * Clones a given node to visually drag around. The original node is left in the same flow as its siblings. Clone
     * styles are added onto the style object directly, since the ::slotted() selector can't universally target nodes
     * that may be nested an unknown amount of shadow dom levels deep.
     *
     * @param {HTMLElement} node
     * @return {Node} clone
     */
    createClone(node) {
        const clone = node.cloneNode(true);
        /**
         * Bugfix for table row sorting.
         * During dragging table rows shrink, so we manually set them width of original node.
         */
        Array.from(clone.children).forEach((nodeChild, index) => {
            const clonedNodeChild = nodeChild;
            const originalNodeChild = node.children.item(index);
            if (originalNodeChild) {
                clonedNodeChild.style.width = `${originalNodeChild.offsetWidth}px`;
            }
        });
        /**
         * We have to copy all user defined properties manually.
         * Lit element prefixes custom properties with '__' so that's why we check for it.
         */
        Object.keys(node)
            .filter((prop) => prop.startsWith('__'))
            .forEach((prop) => (clone[prop] = node[prop]));
        const { offsetLeft: x, offsetTop: y } = node;
        this.initialScrollTop = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
        Object.assign(clone.style, {
            position: 'absolute',
            left: `${x}px`,
            top: `${y}px`,
            willChange: 'transform,opacity',
        });
        clone.classList.add(this.clonedClass);
        return node.parentNode.appendChild(clone);
    }
    render() {
        return html `
      &lt;style>
        :host {
          position: relative;
          display: block;
        }
      &lt;/style>
      &lt;slot>&lt;/slot>
    `;
    }
}
__decorate([
    property({ type: String, attribute: 'handle-selector' })
], SortableElementBase.prototype, "handleSelector", void 0);
__decorate([
    property({ type: String, attribute: 'item-selector' })
], SortableElementBase.prototype, "itemSelector", void 0);
__decorate([
    property({ type: Object })
], SortableElementBase.prototype, "sortableHostNode", void 0);
__decorate([
    property({ type: Boolean, attribute: 'animation-enabled' })
], SortableElementBase.prototype, "animationEnabled", void 0);
__decorate([
    property({ type: String, attribute: 'cloned-class' })
], SortableElementBase.prototype, "clonedClass", void 0);
__decorate([
    property({ type: String, attribute: 'dragged-class' })
], SortableElementBase.prototype, "draggedClass", void 0);
__decorate([
    property({ type: Object, attribute: 'animation-timing' })
], SortableElementBase.prototype, "animationTiming", void 0);
__decorate([
    property({ type: String })
], SortableElementBase.prototype, "orientation", void 0);
//# sourceMappingURL=exmg-sortable-base.js.map</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="https://www.exmachinagroup.com/images/svg/ExMachinaPrimary.svg" style="width: 150px; height: 50px">
    <div class="footer-text">NHN Entertainment. Frontend Development Lab</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
