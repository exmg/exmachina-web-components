# ExMachina WebComponents

## Content

- [Links](#links)
- [Features](#features)
- [Setup](#setup)
- [Development](#development)
- [Configuration Files](#configuration)
- [Commands](#commands)
- [Configuring the Core CMS in projects](#links)

## Links {#links}

[Repository](https://github.com/exmg/exmachina-web-components/)

[Documentation](https://exmg.github.io/exmachina-web-components)

[Demos](https://exmg.github.io/exmachina-web-components/demo/index.html)

## Features {#features}

ExMachina WebComponents packages features and documentations can be found in [Exmg Notion page](https://www.notion.so/exmachina/1396d2022f444059903bd1863e78c23d?v=5350291887d24646b67ac6b4b7c9202d)

## Setup {#setup}

`git clone` the project, then simply run `npm i`

<aside>
ðŸ’¡ Your NPM CLI must be connected to an authorized NPM account on both `@exmg` namespaces in NPM.
To do so, please follow the [instructions](https://docs.npmjs.com/cli/v6/commands/npm-adduser).

</aside>

## Development {#development}

The development process takes place on dedicated feature or fix branches.
Each branch is then merged into `master` branch.

Please refer to the naming conventions for branches in the [good practices section](https://www.notion.so/Branching-26261b1bd7f24a29ada41e59414159ac?pvs=21).

## Configuration Files {#configuration}

### `web-dev-server.config.js`

Allows local development. Defines the root directory of the project and redirects `/demo/index.html` into `/` for simplicity

### `tsconfig.json`

### `jest.config.js`

Jest configuration for modules testing

### `.prettierrc.js`

Based on CMSâ€™s base Prettier configuration in @ExmgLitUtils

### `.prettierignore`

Definition of ignored file by Prettier.
In this case we want to ignore the Typescript style files generated by the Exmg CLI.

### `.eslintrc.yaml`

Based on CMSâ€™s base Eslint configuration in @ExmgLitUtils

### `/src/setup.ts`

This file is a script executed by the command `pre-publish`

```tsx
import { readFileSync, writeFileSync, copyFileSync } from 'fs';
import path from 'path';

const __dirname = path.resolve();

function setup() {
  const source = readFileSync(__dirname + '/package.json').toString('utf-8');
  const sourceObj = JSON.parse(source);
  sourceObj.scripts = {};
  sourceObj.devDependencies = {
    '@exmg/exmg-lit-utils': 'latest', // Sets the exmg-lit-utils as a devDependency in order to be used in CI.
  };
  /**
   * Removes the unnecessary dist prefix in the index file, this way once published,
   * we can import object from the package without targeting any files if the object is exported in index.ts
   */
  if (sourceObj.main.startsWith('dist/')) {
    sourceObj.main = sourceObj.main.slice(5);
  }
  if (sourceObj.module.startsWith('dist/')) {
    sourceObj.module = sourceObj.module.slice(5);
  }
  writeFileSync(__dirname + '/dist/package.json', Buffer.from(JSON.stringify(sourceObj, null, 2), 'utf-8'));
  /**
   * Update version of the app in the file version.ts
   */
  writeFileSync(
    __dirname + '/dist/src/version.js',
    Buffer.from(`export const version = '${sourceObj.version}';`, 'utf-8'),
  );
  // Copy style files and .npmignore
  copyFileSync(__dirname + '/src/styles/main.css', __dirname + '/dist/src/styles/main.css');
  copyFileSync(__dirname + '/src/styles/theme.css', __dirname + '/dist/src/styles/theme.css');
  copyFileSync(__dirname + '/.npmignore', __dirname + '/dist/.npmignore');
}

setup();
```

## Commands {#commands}

```bash
npm start # Starts the CMS
npm run watch # Watches for SCSS change. Used in start
npm run api # Runs the API Generator
npm run tsc # Runs the Typescript building
npm run tsc:watch # Watches for Typescript change. Used in start
npm run test # Runs tests
npm run pre-publish # Prepares the CMS for publishing. Used in CI
npm run release-publish # Publishes the CMS. Used in CI
npm run lint:lit # Lints using Lit-Analizer
npm run lint:eslint # Lints using Eslint
npm run lint:prettier # Lints useing Prettier
npm run format:eslint # Formats using Eslint
npm run format:prettier # Formats using Prettier
npm run lint # Lints using all tools
npm run build:styles # Builds -css.ts files
npm run format # Formats using all tools
```

## Configuring the Core CMS in projects

Once the Core CMS is implemented the developer must integrate a few mandatory files.

In the Playtwo Core CMS, those files are located in `/demo`

In another Core CMS, those files are also located in `/demo`

In a project CMS, those files are located in the root of the project and `/src`

(For more infos on the file locations, see the Good Practices section)

### `environment.js`

```jsx
window.emconfig = {
  version: '5.0.0', // Version of the project (Auto-filled in CI)
  backendHost: 'director.playtwo-dev.playtotv.com', // Backend host
  deployDate: '2019-01-15T09:08:19:806Z', // Deploy date (Auto-filled in CI)
  gatekeeperEnabled: false, // Gate keeper (Auto-filled in CI)
  name: 'playtwo-dev', // Name of the project (Auto-filled in CI)
  settings: {}, // Optional settings
};
```

Most of this file is auto filled when added to OPS

During development, the property `backendHost` allows to change the API endpoint.

<aside>
ðŸ’¡ In a project this file is located in the root of the project

</aside>

### `config.ts`

Expected configuration for the Core CMS. The type is defined in `/src/utils/index.ts`

<aside>
ðŸ’¡ Any edits of the configuration should include a documentation in the type definition

</aside>

```tsx
playTwo: {
	standaloneMode?: boolean; // Set to true only if working from Core CMS
  authBackgroundPath?: string; // Auth background path. Defaults to /src/images/assets/login-bg.png
  authLogoPath?: string; // Auth logo path. Default to /src/images/assets/ExMachinaHigh.svg
  supportEmail?: string; // Email address to contact the support. Defaults to support@exmachinagroup.com
  dateFormat?: string; // Luxon date format used throughout the CMS. Defaults to 'yyyy-LL-dd'
  timeFormat?: string; // Luxon time format used throughout the CMS. Defaults to 'HH:mm'
  notSecuredPaths?: string[]; // Paths of accessible pages without active connection. Defaults to '/auth/login', meaning that a user not connected could only access this page.
};
```

### `index.html`

Main entry point of the application, allows the application to load multiple ressources needed in the CMSs. Those ressources includes:

- Title
  ```tsx
  <title>Ex Machina - PlayTwo Core CMS</title>
  <meta name="description" content="Ex Machina - PlayTwo Core CMS" />
  ```
- Google Fonts
  In order for the CMS to load fonts and icons from Google API
  ```html
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link href="https://fonts.googleapis.com/css?family=Material+Icons&display=block" rel="stylesheet" />
  ```
- Configuration
    <aside>
    ðŸ’¡ Source is set to `/dist` to fetch the JS file associated to `config.ts`
    This source needs to be changed in other implementation of CMSs depending of the location of the configuration TypeScript file
    
    </aside>
    
    ```html
    <script type="module" src="/dist/demo/config.js"></script>
    ```

- Web Component polyfills
  Fetched from `node_modules` folder

  ```html
  <script src="../node_modules/web-animations-js/web-animations-next-lite.min.js" defer></script>
  <script src="../node_modules/@webcomponents/shadycss/apply-shim.min.js"></script>
  ```

    <aside>
    ðŸ’¡ Please refer to build good practices
    
    </aside>

- Environment
  Reference to `evironment.js`
  ```html
  <script src="./dist/demo/environment.js"></script>
  ```
- Code Mirror
  Code Mirror is used in the `@exmg/exmg-markdown-editor` and is mandatory for this component to work.
  Note that some CMS do not implement the `@exmg/exmg-markdown-editor`, then this can be skipped
  ```html
  <script src="../node_modules/codemirror/lib/codemirror.js"></script>
  <script src="../node_modules/codemirror/mode/markdown/markdown.js"></script>
  <script src="../node_modules/codemirror/addon/edit/continuelist.js"></script>
  <script src="../node_modules/codemirror/addon/mode/overlay.js"></script>
  <script src="../node_modules/codemirror/addon/display/fullscreen.js"></script>
  <script src="../node_modules/codemirror/addon/display/placeholder.js"></script>
  <script src="../node_modules/codemirror/mode/gfm/gfm.js"></script>
  <script src="../node_modules/codemirror/mode/xml/xml.js"></script>
  ```
- Styles
  The CMS main style files
  `main.css` includes definition for the authentication part of the CMS and main app layout
  `theme.css` is the file in which the theme of the CMS is set through variables
  ```html
  <!-- Loading main font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500"></link>
  <!-- Loading Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons&display=block"></link>
  <link rel="stylesheet" href="../src/styles/main.css"></link>
  <link rel="stylesheet" href="../src/styles/theme.css"></link>
  ```
- Body
  Implements the `app-wrapper` component, being the entry point of the app
  ```html
  <body>
    <app-wrapper></app-wrapper>
    <script type="module">
      import '../dist/demo/app-wrapper.js';
    </script>
    <noscript> Please enable JavaScript to view this website. </noscript>
  </body>
  ```

### `store.ts`

The store file first create a new Playtwo instance using the sdk

```tsx
const playtwo = createPlayTwo({
  name: 'Playtwo Core CMS Sections',
  endpoint: socketUrl,
  socketOptions: {
    reconnectFactor: 1,
    pingInterval: 2000,
    forever: true,
  },
  silent: true,
});
```

The store file imports the reducers, handlers, actions and states from the SDK, the core, and potential current project and exports a combined object and type from those.

```tsx
export type RootActions = CoreActions & LocalizationActions;
const rootReducer = combineReducers({
  ...coreReducers,
  ...localizationReducers,
});
export type CoreState = ReturnType<typeof rootReducer>;
const coreHandler = combineHandlers(
  adminHandler,
  restrictedContentHandler,
  emailTemplateHandlers,
  serverSettingsHandler,
  textContentHandler,
  timeZoneHandler,
  languageHandler,
  editorHandler,
  entriesHandler,
  categoryHandler,
  categoryStateHandler,
  categoryEntryMappingHandler,
);
```

The store file then uses `rootReducer` and `coreHandler` to set the Playtwo instance.

```tsx
/* Create the store */
const { store: playtwoStore, persistor } = playtwo.createStore<CoreState, any>({
  ...coreReducers,
  ...localizationReducers,
});

/* Set the platformActions.setupPlatform() call to the Redux's persistor object */
const unsubscribe = persistor.subscribe(() => {
  if (persistor.getState().bootstrapped) {
    playtwoStore.dispatch(platformActions.setupPlatform());
    unsubscribe();
  }
});

/* Connects the store to the app */
connectRestricted(playtwoStore);
connectStore(playtwoStore, true); // true is for debug
```

### `app-wrapper.ts`

Main entry point of the CMS, the file imports the `store.ts` file in order to create the store and connects the app through the SDK.

```tsx
@customElement('app-wrapper')
export class AppWrapper extends AppWrapperBaseElement<CoreState> {
  @property({type: Boolean})
  private _needsTwoFactor = false;

  // Disable shadow root for password managers in login form
  createRenderRoot() {
    return this;
  }

  constructor() {
    super();
    this.appRoutes = appRoutes;
    this.authRoutes = authRoutes;
    this.appTitle = 'PlayTwo Core CMS Sections';
    setPassiveTouchGestures(true);
  }

  /***/
```

The class extends from `AppWrapperBase` class which connects the routes for the app and handles user connection.

In the constructor, we set the routes for the authentication and for the app, and finally the app title.

```tsx
/***/
stateChanged(state: CoreState) {
  super.stateChanged(state);
  const twoFactorToken = adminSelectors.twoFactorRequired(state);
  if (this._needsTwoFactor !== !!twoFactorToken) {
    this._needsTwoFactor = !!twoFactorToken;
    goTo('/auth/verify-two-factor');
  }
}

protected render() {
  return html`
    ${this._authInitialized ?
      html`` :
      html`
          <loading-view class="loading"></loading-view>
        `}
    <!-- Default app element incl the main outlet for pages -->
    <app-layout ?signedIn=${this.signedIn || false}>
      <main role="main" id="outlet"></main>
    </app-layout>

    <!-- Auth pages are excluded from shadow dom so native input will be accessible for password managers -->
    <div id="outletAuth"></div>

    <!-- Deafult snackbar used for displaying all in page messages -->
    <exmg-snack-bar></exmg-snack-bar>
    <exmg-browser-warning></exmg-browser-warning>
  `;
}
```

The `stateChanged` function checks when a user connects if the two factor authentication is enabled or not. In case it is, the app routes to the 2FA page for the connected user to enter its SMS code.

The `render` function renders a loading view while the app is loading, once the layout initialized, itâ€™ll render the `app-layout` with the main outlet, the auth outlet and finally the snackbar component used in the app alongside the browser warning.

### `app-layout.ts`

Main layout of the application, sets the app drawer, menu, footer, header and handles the changes in layout when occuring, those include collapsed state for the menu, narrow state in case of small screens, fullscreen state and opened state for the app drawer.

```tsx
protected render() {
    const classes = {
      collapsed: this.collapsed,
      fullscreen: !!this.fullscreen,
      horizontalFlip: !!this.horizontalFlip,
      verticalFlip: !!this.verticalFlip,
      narrow: this.narrow,
      signedIn: true,
      contentContainer: true,
    };
    return html`
      <connection-state-view></connection-state-view>
      ${this.renderDrawer(classes)}

      <div class="main-content ${classMap(classes)}">
        <slot></slot>
      </div>
    `;
  }
```

The `render` function renders the main outlet through the `slot`, the slot is set in the `app-wrapper` component. It renders also the `connection-state-view` that reconnects automatically the app to the websocket in case of lost network.

The `renderDrawer` function renders the drawer, which renders also the menu and the footer.

The function also sets the class map for the main content.

```tsx
private renderMenu() {
  return html`
    ${menu.map((i: MenuItemOrGroupItem) => (isItemGroup(i) ? this.renderGroupItem(i) : this.renderItem(i)))}
  `;
}
private renderGroupItem(i: MenuGroupItem) {
  return html`
    <div class="menu-group-title">${i.title}</div>
    ${i.items.map(
      (subitem: MenuItem) =>
        html`
          <a href=${subitem.path} data-path=${subitem.path} tabindex="-1" class="menu-item">
            <paper-item data-path="${subitem.path}" role="menuitem">
              <svg height="24" viewBox="0 0 24 24" width="24">
                <path d="${subitem.iconPath}"></path>
              </svg>
              <span class="title"> ${subitem.title} </span>
            </paper-item>
            <exmg-tooltip position="right">${subitem.title}</exmg-tooltip>
          </a>
        `,
    )}
    <hr />
  `;
}

private renderItem(i: MenuItem & {roles?: string[]}) {
  return this.hasRole(
    html`
      <a href=${i.path} data-path=${i.path} tabindex="-1" class="menu-item solo">
        <paper-item data-path=${i.path} role="menuitem">
          <svg height="24" viewBox="0 0 24 24" width="24">
            <path d=${i.iconPath}></path>
          </svg>
          <span class="title">${i.title}</span>
        </paper-item>
        <exmg-tooltip position="right">${i.title}</exmg-tooltip>
      </a>
      <hr />
    `,
    i.roles || [],
  );
}
```

The `renderMenu` flow renders the menu in the app drawer. The main item is the `menu` object imported from the menu file.

### `menu.ts`

Defines the menu of the application, the icon, text and path associated with each menu item.

```tsx
export interface MenuItem {
  path: string;
  iconPath?: string;
  icon?: TemplateResult;
  title: string;
  badge?: number | boolean;
}
export interface MenuGroupItem {
  title: string;
  items: MenuItem[];
}
```

The menu file exports an array of `MenuItem` or `MenuGroupItem`

### `app-routes.ts`

Defines the routes of the application. This file must export two different route array, one for the authentication only, and one for the app.
The file must import all the page files that need to be routed.

The app uses the Vaadin Router, for more info see the [NPM Page](https://www.npmjs.com/package/@vaadin/router)

```tsx
/**
 * Pages which are not allowed when user authenticated should be secured by this guard
 */
const twoFactorGuard = (context: Context, command: Commands): any => {
  const store = getConnectedStore<CoreState>();
  const state = store.getState();
  const twoFactorToken = adminSelectors.twoFactorRequired(state);

  if (adminSelectors.isLoggedIn(state) && context.pathname.startsWith('/auth')) {
    return command.redirect('/');
  }
  if (twoFactorToken && context.pathname !== '/auth/verify-two-factor') {
    return command.redirect('auth/verify-two-factor');
  }
};

export const authRoutes: Route[] = [
  {
    path: 'auth',
    name: 'auth',
    action: twoFactorGuard,
    children: [
      {
        path: 'login',
        name: 'login',
        component: 'login-page',
      },
      {
        path: 'forgot',
        name: 'forgot',
        component: 'forgot-page',
      },
      {
        path: 'reset-password',
        name: 'reset-password',
        component: 'reset-password',
      },
      {
        path: 'verify-account',
        name: 'verify-account',
        component: 'verify-account-page',
      },
      {
        path: 'verify-two-factor',
        name: 'verify-two-factor',
        component: 'verify-two-factor-code-page',
      },
    ],
  },
  {
    path: '404',
    component: 'e404-page',
    name: 'not-found',
  },
  { path: '(.*)', redirect: 'auth/login' },
];
```

The authentication routes define a set of route accessible to users not yet connected to the app. The routes for authentication are all under `/auth` ; any time a user changes route it will trigger an action: `twoFactorGuard`, this action allows the CMS to automatically redirect the user to the root route if connected succesfully or to the 2FA page if connected but the 2FA is enabled.

```tsx
export const appRoutes: Route[] = [
  {
    path: '',
    children: [
      {
        path: '',
        redirect: 'settings',
      },
      {
        path: 'admins',
        component: 'admins-page',
        name: 'admins',
      },
      {
        path: 'content',
        component: 'content-page',
        name: 'content',
      },
      {
        path: 'text-content',
        component: 'text-content-page',
        name: 'textContent',
      },
      {
        path: 'email-template',
        component: 'email-template-overview',
        name: 'emailTemplate',
      },
      {
        path: 'settings',
        component: 'settings-page',
        name: 'settings',
        children: [
          {
            path: 'server',
            name: 'Server',
            component: 'server-settings',
          },
        ],
      },
      {
        path: 'localization',
        children: translationRoutes,
      },
    ],
  },
  {
    path: 'auth',
    name: 'auth',
    action: authenticatedGuard, // Checks if the user is already connected, if it is, then redirects to `/`.
    children: [
      {
        path: 'login',
        name: 'login',
        component: 'login-page',
      },
      {
        path: 'forgot',
        name: 'forgot',
        component: 'forgot-page',
      },
      {
        path: 'reset-password',
        name: 'reset-password',
        component: 'reset-password',
      },
      {
        path: 'verify-account',
        name: 'verify-account',
        component: 'verify-account-page',
      },
      {
        path: 'verify-two-factor',
        name: 'verify-two-factor',
        component: 'verify-two-factor-code-page',
      },
    ],
  },
  {
    path: '404',
    component: 'e404-page',
    name: 'not-found',
  },
  { path: '(.*)', component: 'e404-page' },
];
```

The app routes include also authentication routes, this isnâ€™t necessary per say, but associated with an action the CMS can redirect an already connected user trying to access the auth part to the root route.
